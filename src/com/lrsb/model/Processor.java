/**
 * LRSB - Linear Representation Spreedsheat Builder - Pauses Analysis of XML files generated by Translog II software.
 * For Translog II details, see http://bridge.cbs.dk/platform/?q=Translog-II.
 *
 * Developed with a grant from the Federal University of Uberlândia, Brazil (Project 2014PBG000883, Supervisor:
 * Prof. Dr. Igor A. Lourenço da Silva)
 *
 * Copyright (C) 2015 Gabriel Ed. da Silva
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General
 * Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License along with this program. If not, see
 * http://www.gnu.org/licenses/.
 */
package com.lrsb.model;

import static com.lrsb.model.StringTreatment.format2f;
import com.lrsb.spreadsheet.SaveToCSV;
import com.lrsb.xmlElements.Action;
import com.lrsb.xmlElements.Fix;
import com.lrsb.xmlElements.Key;
import com.lrsb.xmlElements.TextFix;
import com.lrsb.xmlElements.XmlEvent;
import com.lrsb.xmlElements.XmlDocument;
import com.lrsb.xmlElements.XmlReader;
import java.io.File;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Classe responsável por processar xmlEvent calcular os indicadores presentes
 * nos arquivos XML.
 *
 * @author gabriel
 */
public class Processor {

    /**
     * Objetos para recuperação de data.
     */
    private static final DateFormat DATE_FORMAT = new SimpleDateFormat("dd/MM/YYYY HH:mm:ss");
    private static final Calendar CALENDAR = Calendar.getInstance();

    /**
     * RF08,RF09
     *
     * @param sourcePath Texto Fonte
     * @param targetPath Texto Alvo
     * @param inputedPauseBegin Inicio do intervalo para validação da pausa
     * @param inputedPauseEnd Fim do intervalo para validação da pausa
     * @param processSingleFile Identifica se processa todos os XMLs em um único
     * arquivo.
     */
    public static void process(String sourcePath, String targetPath, String inputedPauseBegin, String inputedPauseEnd, boolean processSingleFile) {
        ArrayList<Document> documentList = new ArrayList<>();
        File directory = new File(sourcePath);
        String[] directoryFilenames = directory.list();

        if (directoryFilenames == null) {
            return;
        }

        /**
         * RF 08 – O pesquisados deve poder indicar o valor de pausa. O default
         * é de 2400 ms.
         *
         * RF 09 – O pesquisador deve poder determinar o valor mínimo e máximo
         * de uma pausa.
         *
         * Nota: Caso o valor máximo não seja informado, será considerado o
         * valor máximo do tipo de dados inteiro.
         */
        Integer pauseBegin = validatePauseValue(inputedPauseBegin, 2400);
        Integer pauseEnd = validatePauseValue(inputedPauseEnd, Integer.MAX_VALUE);

        /**
         * Processa todos os arquivos do diretório selecionado pelo usuário.
         */
        for (String filename : directoryFilenames) {
            if (filename.endsWith(".xml")) {
                try {
                    /**
                     * Realiza o parse do documento XML
                     */
                    System.out.println("Processando arquivo: " + filename);
                    XmlDocument xmlDocument = XmlReader.parseDocument(sourcePath + File.separator + filename);
                    Document document = Processor.processDocument(xmlDocument, pauseBegin, pauseEnd);
                    System.out.println("Arquivo " + filename + " processado.");

                    /**
                     * Caso o usuário deseje salvar os arquivos em planilhas
                     * separadas o sistema faz a persistência ao fim do
                     * processamento de cada arquivo XML. Caso contrário
                     * adiciona o XML em uma lista para que todos sejam
                     * persistidos em um única planilha posteriormente.
                     */
                    if (!processSingleFile) {
                        Date date = new Date();
                        String savePath = targetPath + File.separator + removeXml(filename) + "+" + date.getTime() + ".csv";
                        SaveToCSV.simpleFileToCSV(document, savePath);
                    } else {
                        documentList.add(document);
                    }
                } catch (Exception ex) {
                    Logger.getLogger(Processor.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }

        /**
         * Persiste todos os XMLs processados em uma única planilha, ela é
         * nomeada com o prefixo all em conjunto com a data do processamento a
         * fim de evitar que os arquivos sejam sobrescritos..
         */
        if (processSingleFile) {
            Date date = new Date();
            String savePath = targetPath + File.separator + "all+" + date.getTime() + ".csv";
            SaveToCSV.singleFileToCSV(documentList, savePath);
        }

        System.out.println("Todos arquivos processados");
    }

    /**
     * Processa uma instância XmlDocument xmlEvent retorna uma instância
     * Document
     *
     * @param xmlDocument XmlDocument
     * @param pauseA Valor inicial do intervalo de pausa
     * @param pauseB Valor final do intervalo de pausa
     * @return Documento processado
     */
    public static Document processDocument(XmlDocument xmlDocument, Integer pauseA, Integer pauseB) {
        Document document = new Document();
        document.setSt(xmlDocument.getSt());
        document.setStLanguage(xmlDocument.getStLanguage());
        document.setSubject(xmlDocument.getSubject());
        document.setTask(xmlDocument.getTask());
        document.setTtLanguage(xmlDocument.getTtLanguage());
        getMicroUnits(xmlDocument, document, pauseA, pauseB);
        return document;
    }

    private static void getMicroUnits(XmlDocument xmlDocument, Document document, Integer pauseBegin, Integer pauseEnd) {
        // Polimorfismo para conseguir todos os Eventos em ordem
        ArrayList<XmlEvent> eventList = new ArrayList<>();
        eventList.addAll(xmlDocument.getFixList());
        eventList.addAll(xmlDocument.getActionList());
        sortEventList(eventList);
        // Variaveis
        Integer difference = Integer.MIN_VALUE;
        Integer microUnitId = 1;
        Integer finalTime = eventList.get(0).getTime();
        Integer initialTime = finalTime;
        Integer fixCountS = 0;
        Integer fixCountT = 0;
        Integer ins = 0;
        Integer del = 0;
        Integer fixDurationS = 0;
        Integer fixDurationT = 0;
        String linearRepresentation = "";
        Segment segment = new Segment();
        Integer previousPause = 0;
        Integer visits = 0;
        Integer previousWindow = 0;
        Integer previousX = null;
        Integer previousY = null;
        Double distance;
        String saccade = "";
        Double saccadeSum = 0.0;
        Integer saccadeAc = 0;
        Integer previousActionTime = Integer.MAX_VALUE;
        Integer currentActionTime = 0;
        Integer fixDurationSPause = 0;
        Integer fixCountSPause = 0;
        Integer fixDurationTPause = 0;
        Integer fixCountTPause = 0;
        String saccadeAngle = "";
        String saccadePause = "";
        String saccadeAnglePause = "";
        Double saccadeSumPause = 0.0;
        Integer visitsPause = 0;
        Integer saccadeAcPause = 0;

        for (int i = 0; i < eventList.size() - 1; i++) {
            segment.setMicroUnitId(microUnitId);
            segment.setStart(initialTime);
            XmlEvent xmlEvent = eventList.get(i);
            difference = Integer.MIN_VALUE;

            if (xmlEvent.getClass() == Key.class) {
                currentActionTime = xmlEvent.getTime();
                difference = currentActionTime - previousActionTime;
                previousActionTime = currentActionTime;
                currentActionTime = 0;
            }

            /**
             * Verifica o tipo de evento e atualiza as variaveis correspondentes
             */
            if (xmlEvent.getClass() == Key.class) {
                Key key = (Key) xmlEvent;
                if ("delete".equalsIgnoreCase(key.getType())) {
                    del++;
                } else if ("insert".equalsIgnoreCase(key.getType())) {
                    ins++;
                }

                linearRepresentation = linearRepresentation + key.getValue();
            } else if (xmlEvent.getClass() == Fix.class) {
                Fix fix = (Fix) xmlEvent;
                if (fix.getWin() == 1) {
                    fixCountS++;
                    fixCountSPause++;
                } else if (fix.getWin() == 2) {
                    fixCountT++;
                    fixCountTPause++;
                }
                // Nota: Não considera visitas inválidas.              
                if ((fix.getWin() != previousWindow) && (fix.getWin() == 1 || fix.getWin() == 2)) {
                    visits++;
                    visitsPause++;
                    previousWindow = fix.getWin();
                }
            } else if (xmlEvent.getClass() == TextFix.class) {
                TextFix textFix = (TextFix) xmlEvent;

                if (textFix.getWin() == 1) {
                    fixDurationS += textFix.getDur();
                    fixCountS++;
                    fixDurationSPause += textFix.getDur();
                    fixCountSPause++;
                } else if (textFix.getWin() == 2) {
                    fixDurationT += textFix.getDur();
                    fixCountT++;
                    fixDurationTPause += textFix.getDur();
                    fixCountTPause++;
                }

                //Verifica se houve uma saccade na microunidade
                if (isSaccade(previousX, previousY, textFix)) {
                    distance = distanceCalculate(previousX, textFix.getX(), previousY, textFix.getY());
                    saccadeSum += distance;
                    saccadeSumPause += distance;
                    saccadeAc++;
                    saccadeAcPause++;

                    saccade += (saccade.isEmpty() ? "" : "+") + format2f(distance);
                    saccadePause += (saccadePause.isEmpty() ? "" : "+") + format2f(distance);
                    saccadeAngle += (saccadeAngle.isEmpty() ? "" : "+") + format2f(Vector.getAngle(previousX, previousY, textFix.getX(), textFix.getY()));
                    saccadeAnglePause += (saccadeAnglePause.isEmpty() ? "" : "+") + format2f(Vector.getAngle(previousX, previousY, textFix.getX(), textFix.getY()));
                }

                previousX = textFix.getX();
                previousY = textFix.getY();
            } else if (xmlEvent.getClass() == Action.class) {
                Action action = (Action) xmlEvent;
                linearRepresentation = linearRepresentation + action.toString();
            }

            /**
             * Verifica se o valor está dentro do intervalo de pausas
             * pré-determinado.
             */
            if (difference >= pauseBegin && difference <= pauseEnd) {
                //Atualiza o tempo final
                finalTime = eventList.get(i + 1).getTime() - 1;

                // Adiciona os valores ao segmento
                segment.setPause(previousPause);
                segment.setEnd(finalTime);
                segment.setDurationM(finalTime - initialTime);
                segment.setLinearRep(linearRepresentation);
                segment.setFixCountS(fixCountS);
                segment.setFixCountT(fixCountT);
                segment.setFixDurationS(fixDurationS);
                segment.setFixDurationT(fixDurationT);

                segment.setMeanDurationT(fixCountT > 0 ? (fixDurationT.doubleValue() / fixCountT) : 0.0);
                segment.setMeanDurationS(fixCountS > 0 ? (fixDurationT.doubleValue() / fixCountS) : 0.0);

                segment.setFixCountST(fixCountT + fixCountS);
                segment.setFixDurationST(fixDurationS + fixDurationT);

                segment.setMeanDurationST(
                    (fixCountT + fixCountS > 0) ? (segment.getFixDurationST().doubleValue() / (fixCountT + fixCountS)) : 0.0
                );

                segment.setFixCountSPause(fixCountSPause);
                segment.setFixDurationSPause(fixDurationSPause);

                segment.setMeanDurationSPause(
                        fixCountSPause > 0 ? (double) fixDurationSPause / fixCountSPause : 0.0
                );

                segment.setFixCountTPause(fixCountTPause);
                segment.setFixDurationTPause(fixDurationTPause);
                
                segment.setMeanDurationTPause(
                  fixCountTPause > 0 ? (double) fixDurationTPause / fixCountTPause : 0.0      
                );

                segment.setFixDurationSTPause(fixDurationSPause + fixDurationTPause);
                segment.setFixCountSTPause(fixCountSPause + fixCountTPause);
                
                segment.setMeanDurationSTPause(
                    (fixDurationSPause + fixDurationTPause > 0) ? (double) segment.getFixDurationSTPause() / segment.getFixCountST(): 0.0
                );

                segment.setVisits(visits);
                segment.setVisitsPause(visitsPause);
                segment.setSaccade(saccade);
                segment.setSacaddeAngle(saccadeAngle);

                if (saccadeAc > 0) {
                    segment.setSaccadeMean(saccadeSum / saccadeAc);
                    segment.setSaccadeSum(saccadeSum);
                } else {
                    segment.setSaccadeMean(0.0);
                    segment.setSaccadeSum(0.0);
                }
                
                segment.setSaccadePause(saccadePause);
                segment.setSaccadeAnglePause(saccadeAnglePause);
                segment.setSaccadeSumPause(saccadeSumPause);

                if (saccadeAcPause > 0) {
                    segment.setSaccadeMeanPause(saccadeSumPause / saccadeAcPause);
                    segment.setSaccadeSumPause(saccadeSumPause);
                } else {
                    segment.setSaccadeMeanPause(0.0);
                }
                segment.setIns(ins);
                segment.setDel(del);

                // Adiciona o segmento ao Documento
                document.getSegments().add(segment);

                //Atualiza as Variaveis
                previousPause = difference;
                finalTime = eventList.get(i + 1).getTime();
                initialTime = finalTime;
                fixCountS = 0;
                fixCountT = 0;
                ins = 0;
                del = 0;
                fixDurationS = 0;
                fixDurationT = 0;
                linearRepresentation = "";
                microUnitId++;
                segment = new Segment();
                visits = 0;
                saccade = "";
                saccadeAngle = "";
                saccadeSum = 0.0;
                fixCountSPause = 0;
                fixCountTPause = 0;
                fixDurationSPause = 0;
                fixDurationTPause = 0;
                saccadePause = "";
                saccadeAnglePause = "";
                saccadeSumPause = 0.0;
                visitsPause = 0;
                saccadeAcPause = 0;
            }

            //if (xmlEvent.getClass() == Action.class || xmlEvent.getClass() == Key.class) {
            if (xmlEvent.getClass() == Key.class) {
                fixCountSPause = 0;
                fixCountTPause = 0;
                fixDurationSPause = 0;
                fixDurationTPause = 0;
                saccadePause = "";
                saccadeAnglePause = "";
                saccadeSumPause = 0.0;
                visitsPause = 0;
                saccadeAcPause = 0;
            }
        }
    }

    /**
     * Ordena os eventos por ordem cronológica
     *
     * @param eList Lista de Eventos
     */
    private static void sortEventList(ArrayList<XmlEvent> eList) {
        Collections.sort(eList, new Comparator<XmlEvent>() {
            @Override
            public int compare(XmlEvent e1, XmlEvent e2) {
                return e1.getTime().compareTo(e2.getTime());
            }
        });
    }

    /**
     * Calcula a distância
     */
    private static Double distanceCalculate(Integer x1, Integer y1, Integer x2, Integer y2) {
        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    }

    /**
     * Remove a extensão XML de uma String
     *
     * @param nome Nome do Arquivo fonte
     * @return Nome sem extensão xml
     */
    public static String removeXml(String nome) {
        return nome.replaceAll(".xml", "");
    }

    /**
     * Valida se o valor das pausas é válido, se não for é retornado o valor
     * padrão.
     *
     * @param inputedPauseValue Valor de pausa informado pelo usuário.
     * @param defaultPauseValue Valor de pausa default caso o informado seja
     * inválido.
     * @return Se o valor de pausa informado for válido, então ele é retornado.
     * Caso contrário é retornado o valor padrão.
     */
    public static Integer validatePauseValue(String inputedPauseValue, Integer defaultPauseValue) {
        try {
            return (inputedPauseValue.matches("^(?!^0)\\d{1,9}$") && Integer.parseInt(inputedPauseValue) >= 0) ? Integer.parseInt(inputedPauseValue) : defaultPauseValue;
        } catch (Exception ex) {
            Logger.getLogger(Processor.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            // Se ocorrer um erro na validação do input, então é retornado o default estipulado.
            return defaultPauseValue;
        }
    }

    private static boolean isSaccade(Integer previousX, Integer previousY, TextFix textFix) {
        return previousX != null && previousY != null && textFix.getX() != null && textFix.getY() != null;
    }
}
