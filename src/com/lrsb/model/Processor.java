/**
 * LRSB - Linear Representation Spreedsheat Builder - Pauses Analysis of XML files generated by Translog II software.
 * For Translog II details, see http://bridge.cbs.dk/platform/?q=Translog-II.
 *
 * Developed with a grant from the Federal University of Uberlândia, Brazil (Project 2014PBG000883, Supervisor:
 * Prof. Dr. Igor A. Lourenço da Silva)
 *
 * Copyright (C) 2015 Gabriel Ed. da Silva
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General
 * Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License along with this program. If not, see
 * http://www.gnu.org/licenses/.
 */
package com.lrsb.model;

import com.lrsb.log.LogControl;
import static com.lrsb.model.StringTreatment.format2f;
import com.lrsb.spreadsheet.SaveToCSV;
import com.lrsb.xmlElements.Action;
import com.lrsb.xmlElements.Fix;
import com.lrsb.xmlElements.Key;
import com.lrsb.xmlElements.TextFix;
import com.lrsb.xmlElements.XmlEvent;
import com.lrsb.xmlElements.XmlDocument;
import com.lrsb.xmlElements.XmlReader;
import java.io.File;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Classe responsável por processar xmlEvent calcular os indicadores presentes
 * nos arquivos XML.
 *
 * @author gabriel
 */
public class Processor {

    /**
     * Objetos para recuperação de data.
     */
    private static final DateFormat DATE_FORMAT = new SimpleDateFormat("dd/MM/YYYY HH:mm:ss");
    private static final Calendar CALENDAR = Calendar.getInstance();

    /**
     * RF08,RF09
     *
     * @param sourcePath Texto Fonte
     * @param targetPath Texto Alvo
     * @param inputedPauseBegin Inicio do intervalo para validação da pausa
     * @param inputedPauseEnd Fim do intervalo para validação da pausa
     * @param processSingleFile Identifica se processa todos os XMLs em um único
     * arquivo.
     */
    public static void process(String sourcePath, String targetPath, String inputedPauseBegin, String inputedPauseEnd, boolean processSingleFile) {
        ArrayList<Document> documentList = new ArrayList<>();
        File directory = new File(sourcePath);
        String[] directoryFilenames = directory.list();
        
        LogControl.log("Iniciando o processamento dos arquivos do diretório ["+sourcePath+"].");

        if (directoryFilenames == null) {
            LogControl.log("O diretório ["+sourcePath+"] não possui arquivos.");
            
            return;
        }

        /**
         * RF 08 – O pesquisados deve poder indicar o valor de pausa. O default
         * é de 2400 ms.
         *
         * RF 09 – O pesquisador deve poder determinar o valor mínimo e máximo
         * de uma pausa.
         *
         * Nota: Caso o valor máximo não seja informado, será considerado o
         * valor máximo do tipo de dados inteiro.
         */
        
        LogControl.log("Valores de pausa informados: ["+inputedPauseBegin+"] - ["+inputedPauseEnd+"].");
        
        Integer pauseBegin = validatePauseValue(inputedPauseBegin, 2400);
        Integer pauseEnd = validatePauseValue(inputedPauseEnd, Integer.MAX_VALUE);

        /**
         * Processa todos os arquivos do diretório selecionado pelo usuário.
         */
        for (String filename : directoryFilenames) {
            if (filename.endsWith(".xml")) {
                try {
                    /**
                     * Realiza o parse do documento XML
                     */
                    LogControl.log("Processando arquivo: ["+ filename+"].");
                    
                    XmlDocument xmlDocument = XmlReader.parseDocument(sourcePath + File.separator + filename);
                    Document document = Processor.processDocument(xmlDocument, pauseBegin, pauseEnd);
                    
                    LogControl.log("Processamento do arquivo ["+filename+"] finalizado.");

                    /**
                     * Caso o usuário deseje salvar os arquivos em planilhas
                     * separadas o sistema faz a persistência ao fim do
                     * processamento de cada arquivo XML. Caso contrário
                     * adiciona o XML em uma lista para que todos sejam
                     * persistidos em um única planilha posteriormente.
                     */
                    if (!processSingleFile) {
                        Date date = new Date();
                        String savePath = targetPath + File.separator + removeXml(filename) + "+" + date.getTime() + ".csv";
                        LogControl.log("Iniciando persistência do arquivo CSV: ["+savePath+"].");
                        
                        if(SaveToCSV.simpleFileToCSV(document, savePath)){
                            LogControl.log("Persistência do arquivo ["+savePath+"] finalizada.");
                        }else{
                            LogControl.log("Erro ao persistir o arquivo ["+savePath+"] .");
                        };
                        
                    } else {
                        documentList.add(document);
                    }
                } catch (Exception ex) {
                    Logger.getLogger(Processor.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }

        /**
         * Persiste todos os XMLs processados em uma única planilha, ela é
         * nomeada com o prefixo all em conjunto com a data do processamento a
         * fim de evitar que os arquivos sejam sobrescritos..
         */
        if (processSingleFile) {
            Date date = new Date();
            String savePath = targetPath + File.separator + "all+" + date.getTime() + ".csv";
            
            if(SaveToCSV.singleFileToCSV(documentList, savePath)){
                LogControl.log("Persistência do arquivo ["+savePath+"] finalizada.");
            }else{
                LogControl.log("Erro ao persistir o arquivo ["+savePath+"].");
            }
        }
        
        LogControl.log("Finalizado o processamento dos arquivos do diretório ["+sourcePath+"].");

    }

    /**
     * Processa uma instância XmlDocument xmlEvent retorna uma instância
     * Document
     *
     * @param xmlDocument XmlDocument
     * @param pauseA Valor inicial do intervalo de pausa
     * @param pauseB Valor final do intervalo de pausa
     * @return Documento processado
     */
    public static Document processDocument(XmlDocument xmlDocument, Integer pauseA, Integer pauseB) {
        Document document = new Document();
        document.setSourceText(xmlDocument.getSourceText());
        document.setSourceLanguage(xmlDocument.getSourceLanguage());
        document.setSubject(xmlDocument.getSubject());
        document.setTask(xmlDocument.getTask());
        document.setTargetLanguage(xmlDocument.getTargetLanguage());
        return getMicroUnits(xmlDocument, document, pauseA, pauseB);
    }

    /**
     * Recupera as informações de microunidades.
     * @param xmlDocument Objeto com as informações processadas do source XML.
     * @param document Documento que irá armazenar as informações processadas.
     * @param pauseBegin Valor do início do intervalo de pausas.
     * @param pauseEnd Valor do término do intervalo de pausas;
     */
    private static Document getMicroUnits(XmlDocument xmlDocument, Document document, Integer pauseBegin, Integer pauseEnd) {
        // Polimorfismo para conseguir todos os Eventos em ordem
        ArrayList<XmlEvent> eventList = new ArrayList<>();
        eventList.addAll(xmlDocument.getFixationList());
        eventList.addAll(xmlDocument.getActionList());
        sortEventList(eventList);
        
        /**
         * Como o primeiro evento não possui evento anterior, os dados de controle
         * são iniciados com o tempo final e inicial iguais ao tempo final do 
         * primeiro evento.
         */
        ControlData controlData = new ControlData(eventList.get(0).getTime());      


        for (int i = 0; i < eventList.size() - 1; i++) {
            controlData.segment.setMicroUnitId(controlData.microUnitId);
            controlData.segment.setStart(controlData.initialTime);
            XmlEvent xmlEvent = eventList.get(i);
            controlData.difference = Integer.MIN_VALUE;

            /**
             * Verifica o tipo de evento e atualiza as variaveis correspondentes
             */
            
            if (xmlEvent.getClass() == Key.class) {
                controlData = processKeyEvent(controlData, xmlEvent);
            } else if (xmlEvent.getClass() == Fix.class) {
                controlData = processFixEvent(controlData, xmlEvent);
            } else if (xmlEvent.getClass() == TextFix.class) {
                controlData = processTextFixEvent(controlData, xmlEvent);
            } else if (xmlEvent.getClass() == Action.class) {
                controlData = processActionEvent(controlData, xmlEvent);
            }

            /**
             * Verifica se o valor está dentro do intervalo de pausas
             * pré-determinado.
             */
            if (controlData.difference >= pauseBegin && controlData.difference <= pauseEnd) {
                controlData = createSegment(controlData, xmlEvent, eventList.get(i + 1).getTime());
                
                // Adiciona o segmento ao Documento
                document.getSegments().add(controlData.segment);

                //Atualiza as variaveis para o novo segmento
                controlData = updateControlData(controlData, eventList.get(i + 1).getTime());
            }
                     
            /**
             * Atualiza as informações de pausa case seja um evento de tecla.
             */
            if (xmlEvent.getClass() == Key.class) {
                updatePauseControlData(controlData);
            }
        }
        
        return document;
    }
    
    /**
     * Processa os eventos de tecla.
     * @param controlData Dados de controle do processamento.
     * @param xmlEvent Evento capturado do xml.
     */
    private static ControlData processKeyEvent(ControlData controlData, XmlEvent xmlEvent){
        controlData.currentActionTime = xmlEvent.getTime();
        controlData.difference = controlData.currentActionTime - controlData.previousActionTime;
        controlData.previousActionTime = controlData.currentActionTime;
        controlData.currentActionTime = 0;

        Key key = (Key) xmlEvent;
        
        if ("delete".equalsIgnoreCase(key.getType())) {
            controlData.del++;
        } else if ("insert".equalsIgnoreCase(key.getType())) {
            controlData.ins++;
        }

        controlData.linearRepresentation = controlData.linearRepresentation + key.getValue();

        return controlData;
    }
    
    /**
     * Processa os eventos de fixação.
     * @param controlData Dados de controle do processamento.
     * @param xmlEvent Evento capturado do xml.
     */
    private static ControlData processFixEvent(ControlData controlData, XmlEvent xmlEvent){
        Fix fix = (Fix) xmlEvent;

        if (fix.getWin() == 1) {
            controlData.fixCountS++;
            controlData.fixCountSPause++;
        } else if (fix.getWin() == 2) {
            controlData.fixCountT++;
            controlData.fixCountTPause++;
        }
        
        /**
         * Identifica se houve visitação (troca de janelas).
         * Nota: Não considera visitas inválidas.  
         */
 
        if ((fix.getWin() != controlData.previousWindow) && (fix.getWin() == 1 || fix.getWin() == 2)) {
            controlData.visits++;
            controlData.visitsPause++;
            controlData.previousWindow = fix.getWin();
        }
        
        return controlData;
    }
    
    /**
     * Processa os eventos de fixação em texto.
     * @param controlData Dados de controle do processamento.
     * @param xmlEvent Evento capturado do xml.
     */
    private static ControlData processTextFixEvent(ControlData controlData, XmlEvent xmlEvent){
                
        TextFix textFix = (TextFix) xmlEvent;

        if (textFix.getWin() == 1) {
            controlData.fixDurationS += textFix.getDur();
            controlData.fixCountS++;
            controlData.fixDurationSPause += textFix.getDur();
            controlData.fixCountSPause++;
        } else if (textFix.getWin() == 2) {
            controlData.fixDurationT += textFix.getDur();
            controlData.fixCountT++;
            controlData.fixDurationTPause += textFix.getDur();
            controlData.fixCountTPause++;
        }

        //Verifica se houve uma sacada.
        if (isSaccade(controlData.previousX, controlData.previousY, textFix)) {
            controlData = processSaccade(controlData, textFix);
        }

        controlData.previousX = textFix.getX();
        controlData.previousY = textFix.getY();
        
        return controlData;
    }
    
    /**
     * Identifica se do evento anterior para o atual houve uma sacada.
     * @param previousX Valor do eixo X do evento anterior.
     * @param previousY Valor do eixo Y do evento anterior.
     * @param textFix Evento de fixação de texto.
     * @return True caso houve uma sacada, Falso caso contrário.
     */
    private static boolean isSaccade(Integer previousX, Integer previousY, TextFix textFix) {
        return previousX != null && previousY != null && textFix.getX() != null && textFix.getY() != null;
    }
    
    /**
     * Processa uma sacada, atualizando os dados de controle.
     * @param controlData Dados de Controle do processamento.
     * @param textFix Evento de fixação de texto.
     * @return Retorna os dados de controle atualizados.
     */
    private static ControlData processSaccade(ControlData controlData,TextFix textFix){
        controlData.distance = distanceCalculate(controlData.previousX, textFix.getX(), controlData.previousY, textFix.getY());
        controlData.saccadeSum += controlData.distance;
        controlData.saccadeSumPause += controlData.distance;
        controlData.saccadeAc++;
        controlData.saccadeAcPause++;
        
        controlData.saccade += (controlData.saccade.isEmpty() ? "" : "+") + format2f(controlData.distance);
        controlData.saccadePause += (controlData.saccadePause.isEmpty() ? "" : "+") + format2f(controlData.distance);
        controlData.saccadeAngle += (controlData.saccadeAngle.isEmpty() ? "" : "+") + format2f(
                getAngle(controlData.previousX, controlData.previousY, textFix.getX(), textFix.getY())
        );
        controlData.saccadeAnglePause += (controlData.saccadeAnglePause.isEmpty() ? "" : "+") + format2f(
                getAngle(controlData.previousX, controlData.previousY, textFix.getX(), textFix.getY())
        );

        return controlData;
    }
        
    /**
     * Processa os eventos de ação.
     * @param controlData Dados de controle do processamento.
     * @param xmlEvent Evento capturado do xml.
     * @return Retorna os dados de controle atualizados.
     */
    private static ControlData processActionEvent(ControlData controlData, XmlEvent xmlEvent){
        Action action = (Action) xmlEvent;
        controlData.linearRepresentation = controlData.linearRepresentation + action.toString();
        
        return controlData;
    }
    
    /**
     * Cria um novo segmento com as informações compreendidas entre as pausas.
     * @param controlData Dados de controle do processamento.
     * @param xmlEvent Evento capturado do xml.
     * @param finalTime Tempo final do segmento.
     * @return Retorna os dados de controle atualizados.
     */
    private static ControlData createSegment(ControlData controlData, XmlEvent xmlEvent,Integer finalTime){
        //Atualiza o tempo final
        //controlData.finalTime = eventList.get(i + 1).getTime() - 1;
        controlData.finalTime = finalTime -1;

        // Adiciona os valores ao segmento
        controlData.segment.setPause(controlData.previousPause);
        controlData.segment.setEnd(controlData.finalTime);
        controlData.segment.setDurationM(controlData.finalTime - controlData.initialTime);
        controlData.segment.setLinearRepresentation(controlData.linearRepresentation);
        controlData.segment.setFixCountS(controlData.fixCountS);
        controlData.segment.setFixCountT(controlData.fixCountT);
        controlData.segment.setFixDurationS(controlData.fixDurationS);
        controlData.segment.setFixDurationT(controlData.fixDurationT);

        controlData.segment.setMeanDurationT(controlData.fixCountT > 0 ? (controlData.fixDurationT.doubleValue() / controlData.fixCountT) : 0.0);
        controlData.segment.setMeanDurationS(controlData.fixCountS > 0 ? (controlData.fixDurationT.doubleValue() / controlData.fixCountS) : 0.0);

        controlData.segment.setFixCountST(controlData.fixCountT + controlData.fixCountS);
        controlData.segment.setFixDurationST(controlData.fixDurationS + controlData.fixDurationT);

        controlData.segment.setMeanDurationST(
            (controlData.fixCountT + controlData.fixCountS > 0) ? (controlData.segment.getFixDurationST().doubleValue() / (controlData.fixCountT + controlData.fixCountS)) : 0.0
        );

        controlData.segment.setFixCountSPause(controlData.fixCountSPause);
        controlData.segment.setFixDurationSPause(controlData.fixDurationSPause);

        controlData.segment.setMeanDurationSPause(
                controlData.fixCountSPause > 0 ? (double) controlData.fixDurationSPause / controlData.fixCountSPause : 0.0
        );

        controlData.segment.setFixCountTPause(controlData.fixCountTPause);
        controlData.segment.setFixDurationTPause(controlData.fixDurationTPause);

        controlData.segment.setMeanDurationTPause(
          controlData.fixCountTPause > 0 ? (double) controlData.fixDurationTPause / controlData.fixCountTPause : 0.0      
        );

        controlData.segment.setFixDurationSTPause(controlData.fixDurationSPause + controlData.fixDurationTPause);
        controlData.segment.setFixCountSTPause(controlData.fixCountSPause + controlData.fixCountTPause);

        controlData.segment.setMeanDurationSTPause(
            (controlData.fixDurationSPause + controlData.fixDurationTPause > 0) ? (double) controlData.segment.getFixDurationSTPause() / controlData.segment.getFixCountST(): 0.0
        );

        controlData.segment.setVisits(controlData.visits);
        controlData.segment.setVisitsPause(controlData.visitsPause);
        controlData.segment.setSaccade(controlData.saccade);
        controlData.segment.setSacaddeAngle(controlData.saccadeAngle);

        if (controlData.saccadeAc > 0) {
            controlData.segment.setSaccadeMean(controlData.saccadeSum / controlData.saccadeAc);
            controlData.segment.setSaccadeSum(controlData.saccadeSum);
        } else {
            controlData.segment.setSaccadeMean(0.0);
            controlData.segment.setSaccadeSum(0.0);
        }

        controlData.segment.setSaccadePause(controlData.saccadePause);
        controlData.segment.setSaccadeAnglePause(controlData.saccadeAnglePause);
        controlData.segment.setSaccadeSumPause(controlData.saccadeSumPause);

        if (controlData.saccadeAcPause > 0) {
            controlData.segment.setSaccadeMeanPause(controlData.saccadeSumPause / controlData.saccadeAcPause);
            controlData.segment.setSaccadeSumPause(controlData.saccadeSumPause);
        } else {
            controlData.segment.setSaccadeMeanPause(0.0);
        }
        controlData.segment.setIns(controlData.ins);
        controlData.segment.setDel(controlData.del);
        
        return controlData;
    }
    
    /**
     * Atualiza os dados de controle após a criação de um novo segmento.
     * @param controlData Dados de controle do processamento.
     * @param finalTime Tempo final do evento.
     * @return Retorna os dados de controle atualizados. 
     */
    private static ControlData updateControlData(ControlData controlData,Integer finalTime){
        controlData.previousPause = controlData.difference;
        controlData.finalTime = finalTime;
        controlData.initialTime = controlData.finalTime;
        controlData.fixCountS = 0;
        controlData.fixCountT = 0;
        controlData.ins = 0;
        controlData.del = 0;
        controlData.fixDurationS = 0;
        controlData.fixDurationT = 0;
        controlData.linearRepresentation = "";
        controlData.microUnitId++;
        controlData.segment = new Segment();
        controlData.visits = 0;
        controlData.saccade = "";
        controlData.saccadeAngle = "";
        controlData.saccadeSum = 0.0;
        controlData.fixCountSPause = 0;
        controlData.fixCountTPause = 0;
        controlData.fixDurationSPause = 0;
        controlData.fixDurationTPause = 0;
        controlData.saccadePause = "";
        controlData.saccadeAnglePause = "";
        controlData.saccadeSumPause = 0.0;
        controlData.visitsPause = 0;
        controlData.saccadeAcPause = 0;
        
        return controlData;
    }
    
    /**
     * Atualiza as informações de pausa dos dados de controle.
     * @param controlData Dados de controle do processamento.
     * @return Retorna os dados de controle atualizados.
     */
    private static ControlData updatePauseControlData(ControlData controlData){
        controlData.fixCountSPause = 0;
        controlData.fixCountTPause = 0;
        controlData.fixDurationSPause = 0;
        controlData.fixDurationTPause = 0;
        controlData.saccadePause = "";
        controlData.saccadeAnglePause = "";
        controlData.saccadeSumPause = 0.0;
        controlData.visitsPause = 0;
        controlData.saccadeAcPause = 0;
        
        return controlData;
    }

    /**
     * Ordena os eventos por ordem cronológica
     *
     * @param eventList Array com uma lista de eventos XML.
     */
    private static void sortEventList(ArrayList<XmlEvent> eventList) {
        Collections.sort(eventList, (XmlEvent e1, XmlEvent e2) -> e1.getTime().compareTo(e2.getTime()));
    }

    
    /**
     * Cálcula a distância euclidiana entre dois pontos.
     * @param x1 Eixo X do primeiro ponto.
     * @param y1 Eixo Y do primeiro ponto.
     * @param x2 Eixo X do segundo ponto.
     * @param y2 Eixo Y do segundo ponto.
     * @return Distância euclidiana entre os dois pontos.
     */
    private static Double distanceCalculate(Integer x1, Integer y1, Integer x2, Integer y2) {
        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    }

    /**
     * Remove a extensão XML de uma String.
     *
     * @param nome Nome do Arquivo fonte.
     * @return Nome sem extensão xml.
     */
    public static String removeXml(String nome) {
        return nome.replaceAll(".xml", "");
    }

    /**
     * Valida se o valor das pausas é válido, se não for é retornado o valor
     * padrão.
     *
     * @param inputedPauseValue Valor de pausa informado pelo usuário.
     * @param defaultPauseValue Valor de pausa default caso o informado seja
     * inválido.
     * @return Se o valor de pausa informado for válido, então ele é retornado.
     * Caso contrário é retornado o valor padrão.
     */
    public static Integer validatePauseValue(String inputedPauseValue, Integer defaultPauseValue) {
        try {
            return (inputedPauseValue.matches("^(?!^0)\\d{1,9}$") && Integer.parseInt(inputedPauseValue) >= 0) ? Integer.parseInt(inputedPauseValue) : defaultPauseValue;
        } catch (Exception ex) {
            Logger.getLogger(Processor.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            // Se ocorrer um erro na validação do input, então é retornado o default estipulado.
            return defaultPauseValue;
        }
    }
    
    /**
     * Realizar o cálculo do ângulo entre duas posições. Para isso são recebidas
     * as coordenadas x,y para duas fixações diferentes. Considera-se que o ângulo
     * é calculado sobre dois vetores, para isso são considerados dois vetores 
     * partindo da posição (0,0) até a posição de cada fixação respectivamente.
     * 
     * Como a posição de inicio do vetor é fixa como (0,0) foi realizada uma
     * simplificação do cálculo matemático para:
     * 
     *  Acos(((x1 * x2) - (y1 * y2)) / (sqrt((x1^2)+(y1^2)) * sqrt((x2^2)+(y2^2)))) * (180/pi).
     * 
     * Código baseado no original disponibilizado em: https://github.com/utluiz/java-playground/blob/master/random-code/src/main/java/br/com/starcode/angulovetores/AnguloVetores.java
     * 
     * @param fixationAx Valor da coordenada x para criação do primeiro vetor.
     * @param fixationAy Valor da coordenada y para criação do primeiro vetor.
     * @param fixationBx Valor da coordenada x para criação do segundo vetor.
     * @param fixationBy Valor da coordenada y para criação do segundo vetor.
     * @return Valor do ângulo calculado entre os dois vetores.
     */
    private static Double getAngle(Integer fixationAx, Integer fixationAy, Integer fixationBx, Integer fixationBy){
        return 
            Math.acos(
                (
                    (fixationAx * fixationBx) + (fixationAy * fixationBy)
                ) / 
                (
                    Math.sqrt(Math.pow(fixationAx, 2.0) + Math.pow(fixationAy, 2.0)) 
                    * Math.sqrt(Math.pow(fixationBx, 2.0) + Math.pow(fixationBy, 2.0))
                )
            ) * (180 / Math.PI);
    };
}

/**
 * Subclasse utilizada para estruturar as informações de controle do processamento.
 * @author gabze
 */
class ControlData {
        public Integer difference;
        public Integer microUnitId;
        public Integer finalTime;
        public Integer initialTime;
        public Integer fixCountS;
        public Integer fixCountT;
        public Integer ins;
        public Integer del;
        public Integer fixDurationS;
        public Integer fixDurationT;
        public String linearRepresentation;
        public Segment segment;
        public Integer previousPause;
        public Integer visits;
        public Integer previousWindow;
        public Integer previousX;
        public Integer previousY;
        public Double distance;
        public String saccade;
        public Double saccadeSum;
        public Integer saccadeAc;
        public Integer previousActionTime;
        public Integer currentActionTime;
        public Integer fixDurationSPause;
        public Integer fixCountSPause;
        public Integer fixDurationTPause;
        public Integer fixCountTPause;
        public String saccadeAngle;
        public String saccadePause;
        public String saccadeAnglePause;
        public Double saccadeSumPause;
        public Integer visitsPause;
        public Integer saccadeAcPause;
        
        public ControlData(Integer finalTime){
            this.difference = Integer.MIN_VALUE;
            this.microUnitId = 1;
            this.finalTime = finalTime;
            this.initialTime = this.finalTime;
            this.fixCountS = 0;
            this.fixCountT = 0;
            this.ins = 0;
            this.del = 0;
            this.fixDurationS = 0;
            this.fixDurationT = 0;
            this.linearRepresentation = "";
            this.segment = new Segment();
            this.previousPause = 0;
            this.visits = 0;
            this.previousWindow = 0;
            this.previousX = null;
            this.previousY = null;
            this.distance = 0.0;
            this.saccade = "";
            this.saccadeSum = 0.0;
            this.saccadeAc = 0;
            this.previousActionTime = Integer.MAX_VALUE;
            this.currentActionTime = 0;
            this.fixDurationSPause = 0;
            this.fixCountSPause = 0;
            this.fixDurationTPause = 0;
            this.fixCountTPause = 0;
            this.saccadeAngle = "";
            this.saccadePause = "";
            this.saccadeAnglePause = "";
            this.saccadeSumPause = 0.0;
            this.visitsPause = 0;
            this.saccadeAcPause = 0;    
        }       
}
